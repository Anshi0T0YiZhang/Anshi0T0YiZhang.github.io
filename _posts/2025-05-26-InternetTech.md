---
layout: post
title: 计算机知识记录
subtitle: "技术探索"
date: 2025-04-18 17:37
author: "yZhang"
header-img: "img/selfTimer/background.jpg"
tags:  
    - 常识
---

## 1.计算机基础知识

## 2.计算机网络分层

### 2.1 IOS/OSI七层模型

IOS/OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。  

### 2.2 TCP/IP四层模型

TCP/IP四层模型：应用层、传输层、网络层、数据链路层。  

## 3.https的握手过程及原理

应用层有哪些协议？  
HTTP：超文本传输协议，用于传输超文本文档。  
HTTPS：HTTP协议的安全版本，采用SSL/TLS加密传输数据。  
CDN：内容分发网络，通过网络加速内容的分发，提高用户访问速度。  
DNS：Domain Name System，用于域名解析。  
FTP：文件传输协议，用于传输文件。  

传统的TLS握手基本都是使用RSA算法来实现密钥交换的。  
在将TLS证书部署到服务端时，证书文件 ≈ 服务端公钥，而私钥则由服务端保存。公钥会在TLS握手阶段传递给客户端。  
在RSA密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密；这样服务端解密后，双方得到了相同的密钥，再用他加密应用消息。  
详细介绍一下"公钥加密"和"私钥解密"过程：  

> ### (1) RSA密钥生成（服务端准备）
>
> 服务端首先生成一对RSA密钥：  
>
> - **私钥** $ (d, n) $
> - **公钥** $ (e, n) $
>
> **生成步骤**：
>
> 1. 选择两个大素数 $ p $ 和 $ q $，计算 $ n = p \times q $。
> 2. 计算欧拉函数 $ \phi(n) = (p-1)(q-1) $。
> 3. 选择整数 $ e $ 满足 $ 1 < e < \phi(n) $ 且 $ \gcd(e, \phi(n)) = 1 $（互质，通常取65537）。
> 4. 计算 $ d $ 使得 $ d = e^{-1} \mod \phi(n) $（即 $ e \cdot d = 1 \mod \phi(n) $）。
>
> **结果**：
>
> - 公钥用于加密，私钥用于解密，且**数学上不可逆向推导**（因大数分解难题）。
>
> ### (2) 客户端：公钥加密过程
>
> 客户端生成随机对称密钥 $ K $，并用服务端公钥 $ (e, n) $ 加密：
>
> **加密公式**：  
> $ C = K^e \mod n $  （$ C $ 为加密后的密文）
>
> **步骤**：
>
> 1. 将密钥 $ K $ 转换为整数（如字节序列的数值表示）。
> 2. 若 $ K $ 较长，需分块并填充（如PKCS#1标准）。
> 3. 计算 $ K^e \mod n $，得到密文 $ C $。
>
> **关键点**：
>
> - 只有公钥 $ e $ 和 $ n $ 被使用，无需私钥。
> - 加密后的 $ C $ 只能通过私钥 $ d $ 解密。
>
> ### (3) 服务端：私钥解密过程
>
> 服务端收到密文 $ C $ 后，用私钥 $ (d, n) $ 解密：
>
> **解密公式**：  
> $ K = C^d \mod n $
>
> **步骤**：
>
> 1. 计算 $ C^d \mod n $，得到原始整数形式的 $ K $。
> 2. 将整数转换回字节序列，恢复对称密钥。
>
> **数学原理**：  
> 根据欧拉定理和RSA设计：  
> $ C^d = (K^e)^d = K^{e \cdot d} = K^{1 + k \cdot \phi(n)} = K \mod n $  
> （因 $ e \cdot d = 1 \mod \phi(n) $，且 $ K $ 与 $ n $ 通常互质）
>
> ### (4) 安全性关键
>
> 1. **单向性**：
>    - 已知 $ C $、$ e $、$ n $，无法逆向计算 $ K $（除非破解大数分解）。
> 2. **密钥隔离**：
>    - 私钥 $ d $ 始终由服务端保密，即使公钥暴露也不影响安全性。
> 3. **前向安全性**：
>    - 若私钥未来泄露，过去的会话密钥仍安全（因每次 $ K $ 随机生成）。
>
> ### (5) 完整流程示例
>
> 1. **服务端**：生成RSA密钥对，发送公钥 $ (e, n) $ 给客户端。
> 2. **客户端**：
>    - 生成AES密钥 $ K = \text{0x123...} $。
>    - 计算 $ C = \text{0x123...}^e \mod n $，发送 $ C $。
> 3. **服务端**：
>    - 计算 $ K = C^d \mod n $，还原 $ K $。
> 4. **双方**：使用 $ K $ 进行对称加密通信（如AES-GCM）。

握手过程：

1. TLS第一次握手：  
   客户端向服务器发起加密通信请求 *ClientHello*。客户端主要向服务器发送以下信息：  
   （1）客户端支持的TLS协议版本  
   （2）客户端生成的**随机数（Client Random）**，后面用于生成<span style="color:rgb(235, 84, 15);">会话密钥</span>条件之一。  
   （3）客户端支持的加密算法列表，如RSA加密算法。  

2. TLS第二次握手：  
   服务器收到客户端请求后，向客户端发出响应，也就是 *SeverHello*。回应的内容包含以下：  
   （1）确认TLS协议版本，如浏览器不支持，则关闭加密通信。  
   （2）服务器生产的**随机数（Sever Random）**，后面用于生成<span style="color:rgb(235, 84, 15);">会话密钥</span>条件之一。  
   （3）服务器证书，包含服务器的公钥和其他信息。  
   （4）服务器支持的加密算法列表，如RSA加密算法。  

3. TLS第三次握手：  
   客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的CA公钥，确认服务器的数字证书真实性。  
   若证书没有问题，**客户端会从数字证书中取出服务器的公钥**，然后使用他的加密报文，向服务器发送容下信息：  
   （1）**随机数（pre-master secret）**，该随机数会被服务器公钥加密（此随机数护法送个服务端，确保两端都是一样的）。  
   （2）加密通信算法改变通知，表示随后的信息都将用<span style="color:rgb(235, 84, 15);">会话密钥</span>加密通信。  
   （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用于服务端校验。  

4. TLS第四次握手：  
   服务器收到客户端的第三个随机数后（pre-master secret），通过协商的加密算法，计算出本次通信的<span style="color:rgb(235, 84, 15);">会话密钥</span>。  
   然后向客户端发送最后的信息：  
   （1）加密通信算法改变通知，表示随后的信息都即将用<span style="color:rgb(235, 84, 15);">会话密钥</span>加密通信。  
   （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用于客户端校验。  

## 4.TCP三次握手和四次挥手

### 4.1 TCP头部格式

<img
  src="/img/InternetTech/TCP_head.png"
  alt="TCP"
  width="40%"
  style="
    border: 1px solid #eee;
    display: block;
    margin: 0 auto 0; /* 下边距设为0px */
  "
/>
<p style="text-align: center; font-weight: bold;">TCP 头部格式</p>

序列号：用来解决网络包乱序问题。  
确认应答号：用来解决丢包的问题。  
控制位：  

- ACK：确认应答位，用来确认上次发送的包到达了对方。  
- SYN：同步位，用来建立连接。  
- FIN：结束位，用来关闭连接。  
- RST：该位为1时，表示出现异常必须强制断开连接。  

### 4.2 TCP三次握手过程

第一次握手：  
客户端向服务器发起连接请求，发送```SYN=1```(同步标志位)，并告知初始序列号。  
状态变化：客户端进入```SYN_SEND```状态。  
第二次握手：  
服务器收到客户端的```SYN=1```请求后，向客户端发起确认应答，发送```SYN=1```和```ACK=1```，并告知确认应答序列号。  
状态变化：服务器进入```SYN_RECV```状态。  
第三次握手：  
客户端收到服务器的```SYN=1```和```ACK=1```确认应答后，向服务器发起确认应答，发送```ACK=1```。  
状态变化：客服端进入```ESTABLISHED```状态。服务器端进入```ESTABLISHED```状态。  

### 4.3 TCP四次挥手过程

### 4.3.1 具体过程

<img
  src="/img/InternetTech/TCP_fourWave.png"
  alt="TCP Four-Wave"
  width="70%"
  style="
    border: 1px solid #eee;
    display: block;
    margin: 0 auto 0; /* 下边距设为0px */
  "
/>
<p style="text-align: center; font-weight: bold;">TCP 四次挥手过程</p>

第一次挥手（```FIN=1```）：  
客户端向服务器发送```FIN=1```，请求关闭连接。  
状态变化：客户端从```ESTABLISHED```状态进入```FIN_WAIT_1```状态。  
含义：

第二次挥手（```ACK=1```）：  
服务器收到客户端的```FIN=1```请求后，向客户端发送确认应答，即```ACK=1```。  
状态变化：客户端从```FIN_WAIT_1```进入```FIN_WAIT_2```状态；服务器从```ESTABLISHED```状态进入```CLOSE_WAIT```状态。  
含义：

第三次挥手（```FIN=1```）：  
服务器向客户端发送```FIN=1```，请求关闭连接。  
状态变化：服务器从```CLOSE_WAIT```状态进入```LAST_ACK```状态。  
含义：

第四次挥手（```ACK=1```）：  
客户端收到服务器的```FIN=1```请求后，向服务器发送确认应答，即```ACK=1```。  
状态变化：客户端从```FIN_WAIT_2```进入```TIME_WAIT```状态，2MSL后进入```CLOSED```状态；服务器从```LAST_ACK```状态进入```CLOSED```状态。  
含义：
