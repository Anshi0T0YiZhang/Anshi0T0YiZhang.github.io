---
title: "「03」特征构建：我能生成新特征吗?"
subtitle: "《特征工程入门与实践》"
layout: post
author: "echisenyang"
header-style: text
hidden: false
catalog: true
tags:
  - book
  - 《特征工程入门与实践》
---



## 特征构建：我能生成新特征吗?

> 在上一章中，我们借助“皮马印第安人糖尿病预测数据集”理解了哪些现有特征最有价值。 在使用现有特征时，我们识别了各列的缺失值，使用不同的方法删除或填充了缺失值，并对数据 进行标准化/归一化，从而提高了机器学习模型的准确率。

> 本章概要：
>
> 1）检查数据集； 
>
> 2）填充分类特征； 
>
> 3）编码分类变量； 
>
> 4）扩展数值特征； 
>
> 5）针对文本的特征构建。

### 2）填充分类特征

> 我们要写一个 自己的转换器，也就是一个填充每列缺失值的方法。
>
> 我们先从定性列 city 开始。对于**数值数据**，可以通过计算**均值**的方法填充缺失值；而对于 **分类数据**，我们也有类似的处理方法：计算出**最常见的类别**用于填充。
>
> `X['city'].fillna(X['city'].value_counts().index[0])`

#### 自定义分类填充器

> 首先，用 scikit-learn 的 TransformerMixin 基类创建我们的自定义分类填充器。这个转换 器（以及本章中的其他转换器）会作为流水线的一环，实现 fit 和 transform 方法。

```python
from sklearn.base import TransformerMixin

class CustomCategoryImputer(TransformerMixin):
    def __init__(self, cols=None):
    		self.cols = cols
    		
    def transform(self, df):
    		X = df.copy() for col in self.cols:
    				X[col].fillna(X[col].value_counts().index[0], inplace=True) 
    		return X
    		
    def fit(self, *_):
    		return self
```

> 我们的 city 和 boolean 列都没有缺失值了。不过**定量列**还是有缺失值。既然默 认的填充器不能选择列，我们再来自定义一个。

#### 自定义定量填充器

> 我们使用的结构和自定义分类填充器类似。主要的区别在于，此处用 scikit-learn 的 Imputer 类实现一个自定义的转换器，对列进行转换：

```python
from sklearn.preprocessing import Imputer 

class CustomQuantitativeImputer(TransformerMixin):
		def __init__(self, cols=None, strategy='mean'):
				self.cols = cols 
				self.strategy = strategy

		def transform(self, df):
				X = df.copy() 
				impute = Imputer(strategy=self.strategy) 
				for col in self.cols:
						X[col] = impute.fit_transform(X[[col]]) 
        return X

		def fit(self, *_):
				return self
```

### 3）编码分类变量

#### 定类等级的编码

```python
pd.get_dummies(X,
							columns = ['city', 'boolean'], # 要虚拟化的列 
							prefix_sep='__') # 前缀（列名）和单元格值之间的分隔符
```

> 我们必须指定需要应用虚拟化的列，因为 Pandas 也会编码定序等级的列，这就没有意义了。 稍后会提及为什么这种操作没有意义。

![](https://gitee.com/echisenyang/GiteeForUpicUse/raw/master/uPic/uNAqQd.png)

#### 定序等级的编码

> ⚠️ 这个等级上仍然存在有用的信息，然而我们需要将字符串转换 为数值数据。在定序等级，由于数据的顺序有含义，使用虚拟变量是没有意义的。为了保持顺序， 我们使用**标签编码器**。

```python
# 创建一个列表，顺序数据对应于列表索引 
ordering = ['dislike', 'somewhat like', 'like'] 
# 0 是 dislike，1 是 somewhat like，2是 like
X['ordinal_column'] = X['ordinal_column'].map(lambda x: ordering.index(x))
```

> ❌ 注意，我们**没有使用 scikit-learn 的 LabelEncoder**，因为这个方法不能像上面的代码那样对 顺序进行编码（0 表示 dislike，1 表示 somewhat like，2 表示 like）。它默认是一个排序方 法，而我们不想这么做。

#### 将连续特征分箱

> ‼️ 有时，如果数值数据是连续的，那么将其转换为分类变量可能是有意义的。例如你的手上有 年龄，但是年龄段可能会更有用。

```python
# 默认的类别名就是分箱 
pd.cut(X['quantitative_column'], bins=3)
>>> 0 (-0.52, 6.333] 
    1 (6.333, 13.167]

# 不使用标签 
pd.cut(X['quantitative_column'], bins=3, labels=False)
>>> 0 0.0 
    1 1.0
```

> 回顾一下，我们对数据集里的列进行了以下这些转换。  
>
> boolean 和 city：虚拟变量编码。 
>
> ordinal_column：标签编码。 
>
> quantitative_column：分箱。

![](https://gitee.com/echisenyang/GiteeForUpicUse/raw/master/uPic/gIlXNb.png)

### 4）扩展数值特征

> 有多种办法可以从数值特征中创建扩展特征。之前我们研究了如何将连续的数值数据转换为 顺序数据，现在开始进一步扩展数值特征。

#### 多项式特征

> 在处理数值数据、创建更多特征时， 一个关键方法是使用 scikit-learn 的 PolynomialFeatures 类。这个构造函数会创建新的列，它们是原有列的乘积，用于捕获特征交互。

```python
poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True) X_poly = poly.fit_transform(X)
```

![](https://gitee.com/echisenyang/GiteeForUpicUse/raw/master/uPic/3DI62l.png)

> sns.heatmap(pd.DataFrame(X_poly, columns=poly.get_feature_names()).corr())
>
> 可以创建关联热图来查看特征交互情况

