name: Notion to Jekyll Sync
on:
  schedule:
    - cron: "0 12 * * *"  # 每日UTC时间12点全量同步
  workflow_dispatch:       # 手动触发同步

jobs:
  sync-notion-pages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize environment
        run: |
          if [ ! -f .notion_cache ]; then
            echo '{"valid_ids":[]}' > .notion_cache
          fi

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          pip install \
            notion-client==2.2.0 \
            python-frontmatter==1.0.0 \
            python-slugify==8.0.1 \
            --index-url https://pypi.tuna.tsinghua.edu.cn/simple \
            --trusted-host pypi.tuna.tsinghua.edu.cn \
            --no-cache-dir

      - name: Run strict sync
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: |
          cat << 'EOF' > notion_to_jekyll.py
          import os
          import json
          import logging
          from notion_client import Client
          import frontmatter
          from slugify import slugify

          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          def get_all_valid_ids(database_id):
              """获取数据库当前所有有效ID"""
              notion = Client(auth=os.environ["NOTION_TOKEN"])
              valid_ids = []
              query = {}
              while True:
                  res = notion.databases.query(
                      database_id,
                      **query,
                      filter={"property": "Status", "select": {"equals": "Published"}}
                  )
                  valid_ids += [p["id"] for p in res.get("results", [])]
                  if not res.get("has_more"):
                      break
                  query["start_cursor"] = res["next_cursor"]
              return valid_ids

          def get_page_content(page_id):
              """获取页面内容"""
              try:
                  blocks = []
                  client = Client(auth=os.environ["NOTION_TOKEN"])
                  result = client.blocks.children.list(block_id=page_id)
                  while True:
                      blocks.extend(result.get("results", []))
                      if not result.get("has_more"):
                          break
                      result = client.blocks.children.list(
                          block_id=page_id,
                          start_cursor=result.get("next_cursor")
                      )
                  return "\n\n".join([_parse_block(b) for b in blocks])
              except Exception as e:
                  logger.error(f"获取内容失败: {str(e)}")
                  return ""

          def _parse_block(block):
              """解析Notion块为Markdown"""
              type_ = block["type"]
              content = block[type_]
              rich_text = content.get("rich_text", [])
              text = "".join([t["plain_text"] for t in rich_text])
              
              if type_ == "paragraph":
                  return text + "\n"
              elif type_ == "heading_1":
                  return f"# {text}\n"
              elif type_ == "heading_2":
                  return f"## {text}\n"
              elif type_ == "heading_3":
                  return f"### {text}\n"
              elif type_ == "bulleted_list_item":
                  return f"- {text}\n"
              elif type_ == "numbered_list_item":
                  return f"1. {text}\n"
              elif type_ == "to_do":
                  checked = "x" if content["checked"] else " "
                  return f"- [{checked}] {text}\n"
              elif type_ == "image":
                  url = content.get("external", {}).get("url") or content.get("file", {}).get("url")
                  return f"![]({url})\n"
              elif type_ == "code":
                  code = "\n".join([t["plain_text"] for t in content["rich_text"]])
                  return f"```{content['language']}\n{code}\n```\n"
              elif type_ == "quote":
                  return f"> {text}\n"
              elif type_ == "callout":
                  icon = content["icon"]["emoji"] if content.get("icon") else ""
                  return f"{icon} **{text}**\n\n"
              elif type_ == "table":
                  return _parse_table(content)
              return ""

          def _parse_table(content):
              """解析表格为Markdown"""
              table_width = content["table_width"]
              rows = []
              for row in content["children"]:
                  cells = []
                  for cell in row["cells"]:
                      cell_text = " ".join([t["plain_text"] for t in cell])
                      cells.append(cell_text)
                  rows.append("| " + " | ".join(cells) + " |")
              if rows:
                  sep = "|" + "|".join(["---"] * table_width) + "|"
                  rows.insert(1, sep)
              return "\n".join(rows) + "\n\n"

          def enforce_consistency(valid_ids):
              """强制保持本地与Notion一致性"""
              cache = json.load(open(".notion_cache")) if os.path.exists(".notion_cache") else {"valid_ids": []}
              
              # 清理无效文件
              deleted = []
              for filename in os.listdir("_posts"):
                  if not filename.endswith(".md"):
                      continue
                  try:
                      with open(f"_posts/{filename}", "r", encoding="utf-8") as f:
                          post = frontmatter.load(f)
                          pid = post.get("notion_id")
                          
                          # 严格删除条件
                          if pid and pid not in valid_ids:
                              os.remove(f"_posts/{filename}")
                              deleted.append(filename)
                              logger.info(f"硬删除文章: {filename}")
                  except Exception as e:
                      logger.error(f"文件处理错误 {filename}: {str(e)}")
              
              # 更新缓存（仅保留有效ID）
              json.dump({"valid_ids": valid_ids}, open(".notion_cache", "w"))
              return deleted

          def main():
              # 获取当前所有有效ID
              valid_ids = get_all_valid_ids(os.environ["NOTION_DATABASE_ID"])
              
              # 执行强制清理
              deleted = enforce_consistency(valid_ids)
              logger.info(f"已清理 {len(deleted)} 篇无效文章")

              # 处理文章更新
              notion = Client(auth=os.environ["NOTION_TOKEN"])
              pages = notion.databases.query(
                  os.environ["NOTION_DATABASE_ID"],
                  filter={"property": "Status", "select": {"equals": "Published"}}
              ).get("results", [])

              for page in pages:
                  try:
                      props = page["properties"]
                      
                      # 提取所有字段
                      title = props["Title"]["title"][0]["plain_text"].strip()
                      date_str = props["Date"]["date"]["start"].split("T")[0]
                      
                      subtitle = ""
                      if "Subtitle" in props and props["Subtitle"]["rich_text"]:
                          subtitle = props["Subtitle"]["rich_text"][0]["plain_text"].strip()
                      
                      header_img = ""
                      if "Header-img" in props and props["Header-img"]["rich_text"]:
                          header_img = props["Header-img"]["rich_text"][0]["plain_text"].strip()
                      
                      tags = []
                      if "Tags" in props and props["Tags"]["multi_select"]:
                          tags = [tag["name"] for tag in props["Tags"]["multi_select"]]
                      
                      content = get_page_content(page["id"])
                      post = frontmatter.loads(content)
                      
                      # 完整Frontmatter字段
                      post.metadata.update({
                          "layout": "post",
                          "title": title,
                          "date": date_str,
                          "subtitle": subtitle,
                          "header-img": header_img,
                          "tags": tags,
                          "catalog": "true",
                          "notion_id": page["id"]
                      })
                      
                      title_slug = slugify(title)
                      filename = f"_posts/{date_str}-{title_slug}.md"
                      
                      # 对比内容差异
                      existing_content = ""
                      if os.path.exists(filename):
                          with open(filename, "r", encoding="utf-8") as f:
                              existing_content = f.read()
                      
                      new_content = frontmatter.dumps(post)
                      if new_content != existing_content:
                          with open(filename, "w", encoding="utf-8") as f:
                              f.write(new_content)
                          logger.info(f"更新文章: {filename}")
                              
                  except Exception as e:
                      logger.error(f"处理失败: {str(e)} (Page ID: {page['id']})")

          if __name__ == "__main__":
              main()
          EOF

          python notion_to_jekyll.py

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Sync: ${{ github.event_name }}"
          file_pattern: |
            _posts/*
            .notion_cache
