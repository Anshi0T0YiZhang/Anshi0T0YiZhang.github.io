name: Notion to Jekyll Sync  V2
on:
  schedule:
    - cron: "0 12 * * *"
  workflow_dispatch:

jobs:
  sync-notion-pages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          pip install \
            notion-client==2.2.0 \
            python-frontmatter==1.0.0 \
            httpx==0.27.0 \
            mdutils==1.5.0 \
            --index-url https://pypi.tuna.tsinghua.edu.cn/simple \
            --trusted-host pypi.tuna.tsinghua.edu.cn \
            --no-cache-dir

      - name: Convert Notion pages to Jekyll posts
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: |
          cat << 'EOF' > notion_to_jekyll.py
          import os
          import logging
          import glob
          from datetime import datetime, timedelta
          from notion_client import Client
          import frontmatter
          import httpx

          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          client = httpx.AsyncClient(timeout=30)
          LAST_SYNC_FILE = '.last_sync'

          async def get_page_content(page_id):
              try:
                  blocks = []
                  notion = Client(auth=os.environ["NOTION_TOKEN"], client=client)
                  result = await notion.blocks.children.list(block_id=page_id)
                  while True:
                      blocks.extend(result.get("results", []))
                      if not result.get("has_more"): break
                      result = await notion.blocks.children.list(
                          block_id=page_id, start_cursor=result["next_cursor"]
                      )
                  return "\n\n".join([_parse_block(b) for b in blocks])
              except Exception as e:
                  logger.error(f"内容获取失败: {str(e)}")
                  return ""

          def _parse_block(block):
              type_ = block["type"]
              content = block[type_]
              rich_text = content.get("rich_text", [])
              text = "".join(t["plain_text"] for t in rich_text if t.get("plain_text"))
              
              # 各类型块处理（保持原有解析逻辑）
              if type_ == "paragraph":
                  return f"{text}\n"
              elif type_ == "heading_1":
                  return f"# {text}\n\n"
              elif type_ == "heading_2":
                  return f"## {text}\n\n"
              elif type_ == "heading_3":
                  return f"### {text}\n\n"
              elif type_ == "bulleted_list_item":
                  return f"* {text}\n"
              elif type_ == "numbered_list_item":
                  return f"1. {text}\n"
              elif type_ == "image":
                  url = content.get("external", {}).get("url") or content.get("file", {}).get("url")
                  return f"![]({url})\n\n"
              elif type_ == "code":
                  code = "\n".join(t["plain_text"] for t in content["rich_text"])
                  return f"```{content['language']}\n{code}\n```\n\n"
              elif type_ == "quote":
                  return f"> {text}\n\n"
              else:
                  logger.warning(f"未处理的块类型: {type_}")
                  return f"\n<!-- Unsupported block type: {type_} -->\n"

          async def main():
              notion = Client(auth=os.environ["NOTION_TOKEN"], client=client)
              database_id = os.environ["NOTION_DATABASE_ID"]

              try:
                  pages = await notion.databases.query(
                      database_id,
                      filter={"property": "Status", "select": {"equals": "Published"}},
                      sorts=[{"timestamp": "last_edited_time", "direction": "descending"}]
                  ).get("results", [])
              except Exception as e:
                  logger.error(f"数据库查询失败: {str(e)}")
                  return

              # 处理元数据字段
              for page in pages:
                  try:
                      props = page["properties"]
                      
                      # 必填字段
                      title = props["Title"]["title"][0]["plain_text"].strip()
                      date_str = props["Date"]["date"]["start"].split("T")[0]
                      
                      # 可选字段处理（带默认值）
                      subtitle = props.get("Subtitle", {}).get("rich_text", [{}])[0].get("plain_text", "") if props.get("Subtitle") else ""
                      tags = [t["name"] for t in props.get("Tags", {}).get("multi_select", [])]
                      catalog = props.get("Catalog", {}).get("checkbox", False)
                      header_img = props.get("Header-img", {}).get("rich_text", [{}])[0].get("plain_text", "") if props.get("Header-img") else ""

                      content = await get_page_content(page["id"])
                      post = frontmatter.Post(content)
                      
                      # 确保所有字段写入frontmatter
                      post.metadata.update({
                          "title": title,
                          "date": date_str,
                          "subtitle": subtitle,
                          "tags": tags,
                          "catalog": catalog,
                          "header-img": header_img,
                          "layout": "post",
                          "notion_id": page["id"],
                          "last_edited": page["last_edited_time"]
                      })

                      filename = f"_posts/{date_str}-{title.replace(' ', '-')}.md"
                      with open(filename, "w", encoding="utf-8") as f:
                          f.write(frontmatter.dumps(post))
                      logger.info(f"生成成功: {filename}")

                  except KeyError as e:
                      logger.error(f"缺少必要字段: {str(e)} (Page ID: {page['id']})")
                  except Exception as e:
                      logger.error(f"处理失败: {str(e)} (Page ID: {page['id']})")

          if __name__ == "__main__":
              import asyncio
              asyncio.run(main())
          EOF

          python notion_to_jekyll.py

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Auto-sync from Notion"
          file_pattern: "_posts/*"
