name: Notion to Jekyll Sync
on:
  schedule:
    - cron: "0 12 * * *"
  workflow_dispatch:

jobs:
  sync-notion-pages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set sync mode
        id: set-mode
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "SYNC_MODE=incremental" >> $GITHUB_ENV
          else
            echo "SYNC_MODE=full" >> $GITHUB_ENV
          fi

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          pip install \
            notion-client==2.2.0 \
            python-frontmatter==1.0.0 \
            requests==2.31.0 \
            python-slugify==8.0.1 \
            --index-url https://pypi.tuna.tsinghua.edu.cn/simple \
            --trusted-host pypi.tuna.tsinghua.edu.cn

      - name: Convert Notion pages to Jekyll posts
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          SYNC_MODE: ${{ env.SYNC_MODE }}
        run: |
          cat << 'EOF' > notion_to_jekyll.py
          import os
          import glob
          import logging
          from datetime import datetime, timezone
          from notion_client import Client
          import frontmatter
          from slugify import slugify

          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
          )
          logger = logging.getLogger(__name__)

          def get_nested_value(data, keys, default=None):
              """通用嵌套数据获取方法"""
              for key in keys:
                  if isinstance(data, dict):
                      data = data.get(key, default)
                  elif isinstance(data, list) and isinstance(key, int) and len(data) > key:
                      data = data[key]
                  else:
                      return default
              return data if data is not None else default

          def process_custom_properties(page_properties):
              """处理自定义字段（保持你的现有结构）"""
              properties = {}
              
              # 必填字段
              properties["title"] = get_nested_value(page_properties, ["Title", "title", 0, "plain_text"], "").strip()
              properties["date"] = get_nested_value(page_properties, ["Date", "date", "start"], "").split("T")[0]
              
              # 可选字段（按你的实际字段名修改）
              custom_fields = {
                  "Subtitle": ["rich_text", 0, "plain_text"],
                  "Header-img": ["rich_text", 0, "plain_text"],
                  "Catalog": ["checkbox"],
                  "Tags": ["multi_select"],
                  "Author": ["select", "name"],  # 示例自定义字段
                  "ReadTime": ["number"]
              }
              
              for field, path in custom_fields.items():
                  properties[field.lower()] = get_nested_value(page_properties, [field] + path)
              
              return properties

          def main():
              # 初始化客户端
              notion = Client(auth=os.environ["NOTION_TOKEN"])
              database_id = os.environ["NOTION_DATABASE_ID"]
              
              # 获取所有有效页面（保持你的筛选条件）
              all_pages = []
              query = {
                  "database_id": database_id,
                  "filter": {
                      "and": [
                          {"property": "Status", "select": {"equals": "Published"}},
                          {"property": "Date", "date": {"is_not_empty": True}}
                      ]
                  }
              }
              
              while True:
                  response = notion.databases.query(**query)
                  all_pages.extend(response.get("results", []))
                  if not response.get("has_more"):
                      break
                  query["start_cursor"] = response["next_cursor"]
              
              logger.info(f"Found {len(all_pages)} published pages")

              # 处理增量同步
              if os.getenv("SYNC_MODE") == "incremental":
                  try:
                      with open(".last_sync_time", "r") as f:
                          last_sync = datetime.fromisoformat(f.read().strip())
                  except:
                      last_sync = datetime(1970, 1, 1, tzinfo=timezone.utc)
                  
                  pages_to_process = [
                      p for p in all_pages
                      if datetime.fromisoformat(p["last_edited_time"].rstrip("Z")) > last_sync
                  ]
                  logger.info(f"Processing {len(pages_to_process)} updated pages")
              else:
                  pages_to_process = all_pages

              # 处理页面生成
              for page in pages_to_process:
                  try:
                      props = process_custom_properties(page["properties"])
                      
                      # 生成文件名
                      title_slug = slugify(props["title"], max_length=50)
                      filename = f"_posts/{props['date']}-{title_slug}.md"
                      
                      # 创建文章内容
                      post = frontmatter.Post("")
                      post.metadata.update(props)
                      post.metadata["layout"] = "post"
                      post.metadata["notion_id"] = page["id"]
                      
                      # 保存文件
                      with open(filename, "w", encoding="utf-8") as f:
                          f.write(frontmatter.dumps(post))
                      
                      logger.info(f"Generated: {filename}")
                      
                  except Exception as e:
                      logger.error(f"Failed to process {page['id']}: {str(e)}")

              # 更新同步时间
              with open(".last_sync_time", "w") as f:
                  f.write(datetime.now(timezone.utc).isoformat())

          if __name__ == "__main__":
              main()
          EOF

          python notion_to_jekyll.py

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Auto-sync from Notion (${{ env.SYNC_MODE }})"
          file_pattern: "_posts/* .last_sync_time"
